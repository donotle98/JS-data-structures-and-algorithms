 def count_ones(a_list):
      total = 0
      for element in a_list:
          if element == 1:
              total += 1
      return total


The above code is a classic example of an O(n) function. This is because we have to loop over every element that we get in order to complete our calculation. We can trace this by following along the code and counting. We're doing a few calculations here.

    1. We're setting total to zero.
    2. We loop through a_list.
    3. We check if element is equal to 1.
    4. We increment total by one a few times.

So setting a counter to zero is a constant time operation. If you think about what's happening inside the computer, we're setting a chunk of memory to some new value. Because we've hard-coded the zero here, it happens in constant time. There's no way to call this function or alter global state that we could change the operation. This is an O(1) operation.

Next, we loop through the list. So we have to look at each item in the list. This number of operations changes depending on the size of the list. If it's a list of 10 things, we do it 10 times. If it's 75, we do 75 operations. In mathematical terms, this means that the time it takes to do something increases linearly with its input. We use a variable to represent the size of the input, which everyone in the industry calls n. So the "loop over the list" function is O(n) where n represents the size of a_list.

Checking whether an element is equal to 1 is an O(1) operation. A way to prove to ourselves that this is true is to think about it as a function. If we had an is_equal_to_one() function, would it take longer if you passed in more values (eg is_equal_to_one(4) vs is_equal_to_one([1,2,3,4,5])? It wouldn't because of the fixed number 1 in our comparison. It took me a while of conferring with other people about why this was true before I was convinced. We decided that binary comparisons are constant time and that's what a comparison to 1 eventually got to.

Next, we increment total by 1. This is like setting total to zero (but you have to do addition first). Addition of one, like equality, is also constant time.

So where are we? We have O(1)+O(n)âˆ—(O(1)+O(1)). This is because we do 1 up front, constant time operation, then (potentially) 2 more constant item things for each item in the list. In math terms, that reduces to O(2n)+O(1). In big O, we only care about the biggest "term" here. "Term" is the mathematical word that means "portion of an algebraic statement".

When finding the runtime of a program with multiple steps, you can divide the program into different sections and add the runtimes of the various sections. You can then take the slowest runtime and use that runtime to describe the entire program

When analyzing the runtime of a program, we care about which part of the program is the slowest.